●クラスの概念とその定義
互いに関連するデータと、それに対する操作(メソッド)をひとまとめにした雛形
 -クラスを定義したたけでは実体は生成されない
 -設計図に例えられる

以下のように定義される

	class (クラス名) { (クラスの記述) }

クラスの構成要素を"メンバー"という
メンバーは以下の2つに分類される
 ・データメンバー
    -フィールド：変数群(メンバー変数)
    -定数
 ・関数メンバー：クラスの機能
    -一般のメソッド
    -コンストラクター
    -etc...


●クラスのインスタンス化
 定義したクラスを扱うには、そのために必要なメモリ領域を確保し、そこにクラスのコピーを
作る必要がある
・コピーの手続きを"インスタンス化"、生成されたコピーを"インスタンス","実体","オブジェクト"
 などと呼ぶ
・インスタンス化には"new演算子"を用いる

	(クラス名) (インスタンス名) = new (クラス名)(引数);


・生成されたインスタンスのメンバーには、以下のようにアクセスする

	(インスタンス名).(メンバー名)


・インスタンスを配列の形で生成できる

	(クラス名)[] (配列名) = new (クラス名)[配列の長さ];

   -foreachループによる一括処理が可能


●メソッドとその定義
 クラスにおいて、処理や(ローカル)変数の集まりである"メソッド"を定義できる
 そのうち、"Main"と名づけられたメソッドはプログラムのエントリポイント(処理の開始地点)の役割を果たす特殊な
メソッドであり、必ずちょうど1つ定義されなければならない
 Mainメソッドのみは、クラスのインスタンス化を必要とせず例外的に呼び出すことができるが、その他のメソッドは
属するクラスをインスタンス化した後、呼び出す必要がある

 メソッドは以下のように定義される

	(アクセス修飾子) (戻り値の型) (メソッド名)( (引数群) ) { (メソッドの記述) }

		アクセス修飾子：定義するメソッドにアクセス可能なクラスを制限する際に用いる
                                制限の必要がない場合は"public"を指定する
                                詳しくは後述

                  戻り値の型  ：メソッドの処理が終了した際、呼び出し元に値を送る必要があれば、
		                その値の型を指定する
                                戻り値が不要な場合は"void"を指定する

		    引数群    ：このメソッドを呼び出す際、引数を与えたい場合は
					( (変数の型 変数名),(変数の型 変数名),…  )
		                のように、引数の型と、メソッド内での名称を必要な個数だけ記す


 また、定義済みのメソッドを呼び出す際には

	(インスタンス名).(メソッド名)( (引数群) );

とする


・メソッドにおける処理は、処理が記述の末尾か、"return文(return;)"に到達した時点で終了され、呼び出し元の
 メソッドに処理を戻す
   -メソッドの戻り値の型を指定した場合、
	return (指定した型の変数);
    とすることで値を1つだけ返すことができる
   -複数の値を返したい場合は、戻り値として構造体(struct)を指定するほか、"outキーワード"を用いた参照渡しなどの
    テクニックが用いられる


●コンストラクター
・インスタンスが生成されるとき、クラスに定義された"コンストラクター"と呼ばれるメソッドが必ず呼び出される
   -フィールドの初期化などに用いられる
   -コンストラクターを明示しない場合は、「何も処理を行わない」という内容のコンストラクターがコンパイラにより
    自動生成される
   -コンストラクターは以下のようなメソッドとして定義される

	public (クラス名)(受け取る引数の型 変数名){ (メソッドの記述) }

     -コンストラクターは、受け取る引数の型の種類に応じて複数定義できる
       -そのうち、引数のないものを"既定のコンストラクター"と呼ぶ
     -インスタンス生成時に引数を指定する場合、その型に対応したコンストラクターが呼び出される
       -引数なしでインスタンスを生成する場合は、既定のコンストラクターが呼び出される
       -"thisキーワード"により、同じクラスの別のコンストラクターを呼び出せる

           public (クラス名)(引数タイプ1) {処理A}
           public (クラス名)(引数タイプ2) : this(引数タイプ1) {処理B}

        2つの引数タイプに対応したコンストラクターを上記のように記述することで、引数タイプ2を使用して
        インスタンスを生成した際、処理A → 処理Bの順に実行される


●クラスの継承
継承：既存のクラス(基本クラス,ベースクラス)を土台として、新たなクラス(派生クラス)を作ること

 派生クラスは以下のように定義できる

	class (派生クラス名) : (基本クラス名) { (派生クラスの記述) }

・派生クラスは基本クラスのメンバーを全て受け継ぐ上、独自のメンバーを追加できる
・派生クラスにもコンストラクターを設定できる
   -派生クラスのインスタンスが生成されたとき、
     フィールドの初期化
     基本クラスのコンストラクター呼び出し
     派生クラスのコンストラクター呼び出し
    という順に処理が行われる
     -基本クラスのコンストラクターのうち、自動で呼び出されるのは既定のコンストラクターのみ
      引数付きのものを呼び出すには、"コンストラクター初期化子"である"baseキーワード"が必要
      以下のようなコンストラクターを派生クラスで定義すればよい

	public (派生クラス名) (引数群) : base(基本クラスのコンストラクターに渡す引数群)


●隠蔽とオーバーライド
 基本クラスのメンバーのうち、派生クラスに不要なもの、変更を加えたいものは"隠蔽","オーバーライド"で上書きできる

      隠蔽     ：派生クラスにおいて、基本クラスに属するものと同名のメンバーを再定義すること
                 再定義により、メンバーは上書きされる
                 可読性のため、隠蔽の際には、メンバーの宣言の戦闘に"newキーワード"を用いることが好ましい

 オーバーライド：メソッドの上書きに使われる手法
                 基本クラスでのメソッド宣言時、"virtualキーワード"を付加しておくと、
                 派生クラスで同名メソッドを"overrideキーワード"を付加して宣言することで上書きできる
                  -virtual付きのメンバーを"仮想メンバー"という

  両者の差異は"ポリモーフィズム"という概念に現れる


●カプセル化とアクセス修飾子
カプセル化：複雑な処理をオブジェクトの内部に隠し、外部からは限定された手段でのみアクセスできるようにするという
            オブジェクト指向の基本的な概念
            安全性や扱いやすさの向上につながる

アクセス修飾子：クラスのメンバーを宣言する際に用いる
                そのメンバー対する外部からのアクセスを制限できる
                    public  制限なし
                   private  同クラスからのみアクセス可能  アクセス修飾子を明示しない場合、自動的に付与
                  protected 同クラスor派生クラスからのみアクセス可能

                   internal 同アセンブリからのみアクセス可能
                             -アセンブリ：.NETにおけるコンパイル済みの実行コードのこと
                                          (基本的には)1つのバイナリファイル(exe,dll)
                                          Visual Studioにおいては各プロジェクトが1つのアセンブリといえる
                  pritected internal 同アセンブリor派生クラスからのみアクセス可能
                   private protected 同アセンブリかつ派生クラスからのみアクセス可能


 また、以下のキーワードにより、データメンバー(変数や定数)を保護できる

   const  初期値の設定と共に付加することで、データメンバーを定数化する(値の代入を禁じる)
 readonly データメンバーを定数化するが、所属するクラスのコンストラクターでも初期化が可能


●アクセサーとプロパティ
カプセル化され、アクセスが制限されたフィールドにアクセス可能な特殊なメソッドを"アクセサー"と呼ぶ
制限の外部から対象のフィールドにアクセスするためには、対応したアクセサーを介する必要がある

プロパティ：privateで宣言されたフィールドの値を設定・取得するアクセサーを簡単に作成するための機能

 クラス作成側：メンバーの状態変更は全てメソッドを通したい
                →クラス内部から見るとメソッドのように振る舞う
 クラス利用側：メンバーに直接アクセスしたい(記述が楽)
                →クラス外部から見るとメンバー変数のように振る舞う
                  直接フィールドを操作しているかのような簡単な記述でアクセスが可能

プロパティは以下のように定義できる

	(アクセス修飾子) (対象のデータ型) (プロパティ名)
	{
	    set { (代入時の処理,変数valueを宣言なしで使用可能) }

	    get { (参照時の処理,return文で終わる) }
	}

他クラスから呼び出す際は、代入演算子"="を用いた場合setが、参照のみの場合getが呼び出される

	(インスタンス名).(プロパティ名) = (代入したい値);     ←setが実行(右辺の値がvalueに代入される)
        Console.WriteLine( (インスタンス名).(プロパティ名) ); ←getが実行され、値がreturnされる

・set,getは片方のみを定義することもできる
・set,getの定義時、それぞれにアクセスレベルの設定(例：protected set)が可能


●自動プロパティ
 プロパティを設定する際、set,getの処理が単純な値の代入・参照のみであれば、自動プロパティという
機能により記述を省略できる
 変数の定義時、以下のように記述することで自動プロパティは定義される

	public (データ型) (変数名) { set; get;}
	public (データ型) (変数名) { set; get;} = (初期値); //初期値の設定を行いたい場合

 コンパイル時には 変数の宣言 + 対応するプロパティの作成 という処理と同等のプログラムが生成される


●静的メンバーと静的クラス
 クラスのメンバーのうち、特定のインスタンスから独立したものを"静的メンバー"と呼ぶ
  -"staticキーワード"を付加して定義する
 静的メンバーは、インスタンスを作成せずとも呼び出すことができる

	(クラス名).(メンバー名)

・静的なフィールド(変数)への変更は、そのクラスの全てのインスタンスに影響する
・静的メソッドでは、静的なデータメンバーしか扱うことができない
・静的に定義されたコンストラクターは以下の特徴を持つ
   -対応するクラスの1つ目のインスタンスが作成されたとき、またはクラスの静的メンバーが呼び出されたとき、
    1度だけ呼び出される
     -ただし,呼び出されるタイミングを厳密に定義することはできない
   -アクセス修飾子や引数は指定できない
