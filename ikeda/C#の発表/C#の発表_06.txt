●多次元配列
配列定義時,[]の中に","を記述した数だけ次元を増やせる

	〇例
		int[,] a = new int[3,5];

	と記述することで

		a[0,0],a[0,1],a[0,2],a[0,3],a[0,4]
		a[1,0],a[1,1],a[1,2],a[1,3],a[1,4]
		a[2,0],a[2,1],a[2,2],a[2,3],a[2,4]

	という15個のデータを持つ配列が定義できる
	 また,初期化は以下のように行える

		int[,] a = { {1,2,3,4,5}, {6,7,8,9,10}, {11,12,13,14,15} };


●ジャグ配列
配列とは,「特定のデータ型の要素の集まり」と表現できるが,配列を要素として持つ配列も問題なく定義できる
このような配列をジャグ配列という

	〇例
		int[][] a = new int[3][];

	と記述することで,aは「int配列を要素として持つ長さ3の配列 = { a[0][], a[1][], a[2][] }」として定義され,
	各要素の配列は
		a[0] = new int[3];
		a[1] = { 1, 2, 3, 4 };
		a[2] = { 2, 4 };
	のように定義・初期化できる


●構造体
以下のように定義できる

	struct (構造体の名前) { (メンバーの記述) }

ほとんどクラスと同じはたらきをするが,いくつか異なる点があり,場合に応じて適切に使い分けることが求められる

   [クラスとの相違点]
   ・クラスは参照型だが,構造体は値型である
      -構造体の方がデータへのアクセスは速くなるが,実体が大きくなりすぎるとメモリ領域や処理上の負荷が大きくなる
      -16byteくらいまでなら構造体の方が動作が速い？？

   ・構造体は他のクラスを継承できず,自身が継承元となることもできない
      -ただし,構造体でもインターフェースの実装は可能

   ・構造体ではフィールド初期化子を用いることができない
      -必ずコンストラクターなどで初期化しなければならない

   ・構造体では既定のコンストラクター(引数なしのもの)は定義できない
      -引数なしでインスタンスを生成した場合は,フィールドには規定値が入る
        -規定値とは各変数のデフォルトの値のことで,型ごとに定義されている
          例：int型の規定値は0
              bool型の規定値はfalse
              string型の規定値はnull

 →説明_014


・また,構造体とそのフィールドの全てにreadonlyキーワードを付与することで,その構造体を読み取り専用にできる
  この場合,フィールドの変更はコンストラクターのみ可能となる

・実は,組み込み型(C#であらかじめ用意されている変数の型)は,全て.NETで定義された構造体やクラスの別名(エイリアス)である

	〇例
	  int  System.Int32構造体
	 float System.Single構造体(単精度浮動小数点数を表す構造体)

	string System.Stringクラス
	 配列  System.Arrayクラス


●コレクション


●デリゲート


●ラムダ式
