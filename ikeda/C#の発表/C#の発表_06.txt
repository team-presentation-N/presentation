●多次元配列
配列定義時,[]の中に","を記述した数だけ次元を増やせる

	〇例
		int[,] a = new int[3,5];

	と記述することで

		a[0,0],a[0,1],a[0,2],a[0,3],a[0,4]
		a[1,0],a[1,1],a[1,2],a[1,3],a[1,4]
		a[2,0],a[2,1],a[2,2],a[2,3],a[2,4]

	という15個のデータを持つ配列が定義できる
	 また,初期化は以下のように行える

		int[,] a = { {1,2,3,4,5}, {6,7,8,9,10}, {11,12,13,14,15} };


●ジャグ配列
配列とは,「特定のデータ型の要素の集まり」と表現できるが,配列を要素として持つ配列も問題なく定義できる
このような配列をジャグ配列という

	〇例
		int[][] a = new int[3][];

	と記述することで,aは「int配列を要素として持つ長さ3の配列 = { a[0][], a[1][], a[2][] }」として定義され,
	各要素の配列は
		a[0] = new int[3];
		a[1] = { 1, 2, 3, 4 };
		a[2] = { 2, 4 };
	のように定義・初期化できる


●構造体
以下のように定義できる

	struct (構造体の名前) { (メンバーの記述) }

ほとんどクラスと同じはたらきをするが,いくつか異なる点があり,場合に応じて適切に使い分けることが求められる

   [クラスとの相違点]
   ・クラスは参照型だが,構造体は値型である
      -構造体の方がデータへのアクセスは速くなるが,実体が大きくなりすぎるとメモリ領域や処理上の負荷が大きくなる
      -16byteくらいまでなら構造体の方が動作が速い？？

   ・構造体は他のクラスを継承できず,自身が継承元となることもできない
      -ただし,構造体でもインターフェースの実装は可能

   ・構造体ではフィールド初期化子を用いることができない
      -必ずコンストラクターなどで初期化しなければならない

   ・構造体では既定のコンストラクター(引数なしのもの)は定義できない
      -引数なしでインスタンスを生成した場合は,フィールドには規定値が入る
        -規定値とは各変数のデフォルトの値のことで,型ごとに定義されている
          例：int型の規定値は0
              bool型の規定値はfalse
              string型の規定値はnull

 →説明_014


・また,構造体とそのフィールドの全てにreadonlyキーワードを付与することで,その構造体を読み取り専用にできる
  この場合,フィールドの変更はコンストラクターのみ可能となる

・実は,組み込み型(C#であらかじめ用意されている変数の型)は,全て.NETで定義された構造体やクラスの別名(エイリアス)である

	〇例
	  int  System.Int32構造体
	 float System.Single構造体(単精度浮動小数点数を表す構造体)

	string System.Stringクラス
	 配列  System.Arrayクラス


●コレクション
同じ型のデータをまとめて管理するためのデータ構造を"コレクション"という
System.Collections名前空間のクラスや,System.Arrayクラスで定義されたものがそれに当たる

〇配列
 宣言時にデータの保管場所をヒープ領域に確保し,その場所一つ一つにインデックス(0以上の整数)を紐付ける
  -保存されるデータたちは直線的に整列され,インデックスとデータが一対一に対応する
    -データ代入時は,どのインデックスと紐付けるかを指定する

	var array = new int[5];      =>      { x, x, x, x, x }  長さ5の領域が確保される
	array[2] = 3;                =>      { x, x, 3, x, x }  インデックス[2]に対応する領域に値が代入される

〇リスト
 宣言時にそのサイズ(長さ)を定義する必要が無く,データ保存領域も最初に確保されるわけではない
  -データを書き込む際には「代入」ではなく「追加」の処理を行う
  -それぞれのデータには次の要素が何であるか(どのアドレスから始まる記述なのか)が紐付けられている

	var intlist = new List<int>();    =>   List<int>型のインスタンスが生成

	intlist.Add(2);                   =>   Address0x..1 { 2, x }
                                               先頭の要素が追加される 次の要素は未定義

        intlist.Add(5);                   =>   Address0x..1 { 2, 0x..3 }
                                               Address0x..3 { 5, x }
	                                       2つ目の要素が追加され,先頭の要素に対応するアドレスが紐付けられる

〇ディクショナリー
〇スタック
〇キュー


●デリゲート


●ラムダ式
