●例外の発生と例外クラス
アプリケーションの動作中に発生する異常を"例外"という
例外には以下の2パターンが存在する
 ・ランタイム例外
    .NETが自動的に発生させる例外
      →説明_007(ゼロ除算)
      →説明_008(配列インデックスの不正参照)
 ・カスタム例外
    プログラマが明示的に発生させる例外

C#においては,System.Exceptionの派生クラス(例外クラス)のインスタンスが実際に発生した例外と一対一に対応している

  プログラム内で例外が発生 ⇔ 例外クラスのインスタンスが生成

例外が発生し,例外クラスのインスタンスが生成されることを,"例外がスローされる"という
 -"var inst = new Exception();"などにより,正常処理の範囲内で例外クラスのインスタンスを生成する場合を考慮すると,
  上記の説明は必ずしも正しくないが,通常は例外クラスのインスタンスを正常処理では作成しない


●例外処理とtry-catch文
例外への対処を講じない場合,発生した例外の種類によってはアプリケーションが処理の途中で停止してしまう
それを防ぐため,例外の発生を予測し,それに対する適切な処理を組み込むことを"例外処理"という

例外インスタンスがスローされたことを検知する手段として,"try-catch"文が用いられる

	try
	{
	    (例外を検出したい処理)
	}
	catch
	{
	    (例外発生時の処理)
	}
	finally
	{
	    (例外の有無によらず実行する処理,省略可)
	}

 →説明_009

catchブロックでは,発生した例外インスタンスの型によって処理を分岐させたり,例外インスタンスの情報を読み取ったりすることができる

	catch(処理したい例外の型1 例外インスタンスを表す変数)
	{
	    (処理)
	}
	catch(処理したい例外の型2 例外インスタンスを表す変数)
	{
	    (処理)
	}

 →説明_010


●例外の種類とカスタム例外
.NET側で定義されたランタイム例外には以下の種類があり,例外の種類に応じて自動的に選択される
https://docs.microsoft.com/ja-jp/dotnet/api/system.exception?view=netcore-3.1#remarks

ランタイム例外に存在しない種類の例外をスローしたい場合,アプリケーション側でカスタム例外のクラスを定義した上で,そのインスタンスをスローする必要がある
カスタム例外のクラスはSystem.Exceptionやその派生クラスを継承して定義される


●例外の手動スロー
例に挙げた「ゼロ除算」や「配列インデックスの不正参照」のケースでは,それらの例外が発生したタイミングで.NET側が自動的に例外インスタンスをスローしていた
一方,カスタム例外クラスを利用したい場合や,ランタイム例外インスタンスを手動スローしたい場合には"throw文"が使用される

	throw new (例外の型)(コンストラクターへ渡す引数);

 →例：GnssL1SParser


●例外の再スロー
tryブロックの内部に更にtry-catch文を構成することで,段階的な例外処理を行える
catch文の内部でthrow文が実行された場合,catchされている例外インスタンスが外部に向けて再びスローされる

 →説明_011


●例外設計論
・スローした例外をいつcatchすべきか？
   捕まえる例外に制限を掛けていないcatch文には,あらゆる例外の回復が求められてしまう
    -catch文を抜けた後は正常処理に戻るため
    -どんな例外が発生してもとりあえず動き続けるアプリケーションやクラスはcatch文の濫用により簡単に作れるが,それらの本来の役目とは異なる挙動になってしまう

   対象のメソッド内で回復可能な例外と,そうでない例外とを判別した上で回復処理を行う必要がある
   則ち,そのメソッド(クラス)で回復可能な例外のみcatchし,そうでない例外はより上の階層(呼び出し元)でcatchすべき


・例外として扱うべきか,正常処理の範囲内で解決すべきか
   アプリケーションの処理をそのままでは続行できないケースであっても,例外として扱うべきでないケースがある

    -正常処理の範囲で想定内のケースに関しては,条件分岐によって正常処理として回復すべき
      →説明_012 ゼロ除算に対する処理を正常処理の範囲で行っている
     つまり,全てのtry-catchを外しても正常処理を遂行できるように設計すべき

    -「契約による設計」から考える例外処理のあり方
       -ルーチン(メソッド)を呼び出す際は,そのルーチンが要求する「事前条件」を満たさなければいけない
       -呼び出されたルーチン(メソッド)は,呼び出し側がその「事前条件」を満たしているならば,処理を行った後に「事後条件」を満たさなければならない

       -事前条件を満たさない呼び出し
         -呼び出し元に責任がある → 例外をスローすべきでない
       -事前条件が満たされたが,メソッド内の処理に失敗した場合
         -メソッドに責任がある → メソッド内に問題がある場合：呼び出し元に例外をスロー(事後条件が満たされない)
                               → メソッド外に問題がある場合：呼び出し元に例外をスロー or 正常処理として,エラーの発生を呼び出し元に戻り値として伝える

       -処理失敗時にそれを例外の形で伝えるか,戻り値の形で伝えるかは場合によって異なる
        つまり,それ自体が一つの事後条件だといえる
