●値型と参照型
メモリ領域は「スタック領域」と「ヒープ領域」に分けられる

全ての変数は,定義された時点でスタック領域にデータの格納場所が確保される
 -サイズが決まっている変数は,スタック領域の対応するアドレスにデータがまるごと格納される
    例：int型(32bit)の変数を定義した場合,スタック領域から32bitの領域が確保され,代入された値がその領域に格納される
  このような変数を,「値型」という
    [値型変数の例]
       int  32bit 値域は      -2^31     〜   2^31 - 1
      float 32bit 値域は ±1.5x10^(-45) 〜 ±3.4x10^38

 -不定なサイズの変数(string型,class,配列など)に関しては,ヒープ領域にデータが保存され,スタック領域にはそのアドレスのみが格納される
    例：string型の変数を定義した場合,ヒープ領域に実体を格納するための領域が確保され,スタック領域にはそのアドレス(サイズは環境依存)が格納される
  このような変数を,「参照型」という

参照型変数a,bに対して,代入操作
	b = a;
は,aに対応するスタック領域のデータ(aの実体があるヒープ領域のアドレス)を,bに対応するスタック領域に代入することに対応する
即ち,代入が行われた以降,変数a,bはまったく同じ意味を持つ


●値渡しと参照渡し
メソッドに引数を渡す際,特に指定しなければ,引数の値がメソッドが持つ仮パラメーターにコピーされた後,処理が行われる
これを引数の「値渡し」という
メソッド内で扱われるのはあくまで元の引数のコピーなので,メソッドの処理が元の引数に直接影響することはない
 →説明_001

一方,メソッドの引数の定義と,呼び出し時の引数に"refキーワード"を付与することで,引数のアドレスをメソッドに渡し,
引数そのものをメソッドに処理させることができる
これを引数の「参照渡し」という
 →説明_002


●可変パラメーター
通常,メソッドの引数の個数はメソッド定義時に指定されるが,"paramsキーワード"を用いることで,特定の型の引数であれば,いくつでも受け付けることができる
 →説明_003


●メソッドのオーバーロード(overload,過積載)
同じ名前だが,受け付ける引数が異なる複数のメソッドを定義することができる
メソッドを呼び出す際は,与えた引数に対応したメソッドが呼び出される
 →https://docs.microsoft.com/ja-jp/dotnet/api/system.console.writeline?view=netcore-3.1
 →https://docs.microsoft.com/ja-jp/dotnet/api/system.int32?view=netcore-3.1


●outキーワードにより戻り値を複数定義する
通常,メソッドの戻り値は1つしか定義できないが,"outキーワード"を用いることで,複数の戻り値を定義できる
 →説明_004


・ローカル関数
   メソッドの内部でメソッドを定義することができる
   そのようなメソッドを「ローカル関数」と呼ぶ
   ローカル関数は,定義されたメソッドの内部でしか呼び出すことができない

・オブジェクト初期化子
   クラスのインスタンスの生成時,同時にそのメンバーを初期化することができる
	var (インスタンス名) = new (クラス名) { メンバー1 = 初期値, メンバー2 = 初期値,… };

・パーシャルクラスとパーシャルメソッド
   "partialキーワード"により,クラスやメソッドの定義を複数に分割して行うことができる
