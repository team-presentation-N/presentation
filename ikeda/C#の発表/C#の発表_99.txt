●例外処理の補足
・catchブロック内で例外がthrowされた場合でも,finally文は実行される

・when句を用いることで,catchするかどうかをbool型の評価により分岐できる
   [例]
     catch (Exception ex) when (ex is IOException | ex is ArgumentException)
     {
         //処理
     }
     catch (Exception ex)
     {
         //その他の場合の処理
     }

  どの型の例外発生時でも必ずはじめに行う処理がある場合は,常にfalseを返す自作メソッドにその処理を実装し,
  catch文の先頭で
    catch (Exception ex) when ( メソッド ) { (なにもしない) }
  とすればよい

・例外オブジェクトにはDataプロパティ(KeyとValueが共にObject型のDictionary)がある
  これにより,例外に情報(回復可能性など)を追加できる


●ref,out,inキーワードの違い
全て参照渡しの際に用いられるが,細部のふるまいが異なる
 ref 初期化済み変数しか扱えない
 out 初期化されていない変数も扱えるが,メソッド内で代入を行う必要がある
 in  メソッド内での代入が禁止される(i.e.読み取り専用の参照渡しとなる)
     値渡しに近いふるまいになるが,メソッドへ値がコピーされることにより発生する処理時間やメモリを節約できる


●ジェネリック
対象の型は複数あるが,全てに同じ処理を行いたい場合に活用できる機能
https://qiita.com/taumax/items/2af451a2c331e8ded892

・ジェネリックメソッド
   複数種の引数を扱えるメソッドを,オーバーロードを用いず,統一的に記述できる

	(アクセス修飾子) (戻り値の型) (メソッド名)<型名を表す変数>(引数) { (処理) }

   上記のように定義したメソッドはあらゆる型の引数に対応しており,<>内で定めた型名変数をメソッド内で自由に扱うことができる
   呼び出す際には以下のように記述する

	(メソッド名)<実際に渡す引数の型>(引数);

   このとき,<>で指定する引数の型は省略できる

   ただし,一般の変数に対して行える処理は限定的であり,ジェネリックメソッド内の仮変数に対する処理も制限される
     例："変数名.GetType()" など,System.Objectでサポートされている処理は一般の変数に対して定義されている
         "変数名 + 変数名" や "3 * 変数名" などは広く扱われる演算子だが,一般の変数に対して演算は定義されていない
     →説明_013

   「ジェネリック型制約(whereキーワード)」という機能により,ジェネリックメソッドに渡せる引数の型を制限し,メソッド内で扱える処理の幅を広げることができる
    詳細：https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/keywords/where-generic-type-constraint

   [ジェネリックメソッドの利点]
   戻り値の型に幅を持たせることができる


●ダイナミック
https://ufcpp.net/study/csharp/sp4_dynamic.html


☆未説明の項目
§6 クラスとメソッドの基礎
・メソッドのパラメーター関連
   -名前付きパラメーター
   -パラメーターの省略
   -inキーワードでの参照渡し
   -戻り値を参照により定義する
   -thisキーワード

§8 ポリモーフィズム
   -ボックス化
   -型スイッチ

§9 例外処理
   -checked-unchecked

§10 配列と構造体
   -タプル
   -null許容型,??演算子

§11 高度なプログラミング
   -Parallelクラス
